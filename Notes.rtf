{\rtf1\ansi\ansicpg1252\cocoartf1671\cocoasubrtf500
{\fonttbl\f0\fswiss\fcharset0 Helvetica;\f1\fswiss\fcharset0 Helvetica-Oblique;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\margl1440\margr1440\vieww15480\viewh8320\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs24 \cf0 Udemy AWS Severless- API & Apps Course Notes\
\
Section 1.6 \
- There are more advanced ways of creating APIs (e.g. by importing API definition files).\
- Mock response under the "Get" Method is a dummy response. \
- Stages are a feature which allow you to manage different versions of the API, like a development API and a production API.\
- remember to add to the end of the link. https://l3dtr5aq3b.execute-api.us-east-2.amazonaws.com/Development/first-api-udemy \
\
Section 1.7\
-Alternates to AWS include Microsoft's Azure and Google Cloud Platform\
\
Section 2.12\
-S3 (Simple Storage Service)\
  - doesn't support any server-side code\
-API Gateway\
  - a service to create API with different paths and HTTP methods we want to handle\
-Lambda\
  - allows you to execute code on demand\
-DynamoDB\
  - NoSQL database where we don't have to provision any database servers. \
-Cognito\
  - creates user pools to allow users to sign-up and then sign themselves in.\
-Route 53\
  - allows us to register and configure our own domain. \
-Cloud front (optional)\
  - caching service used to improve performance and delivery time \
  - basically copy your static files to always have the quickest route possible\
\
\
Section 3.16\
-API Gateways can create endpoints, which are combinations of resources, paths and HTTP methods so that you can get URLs.\
\
Section 3.19\
- API keys are interesting if you plan on creating an API  which is shared with other developers\
- API keys used to identify the calling program, its developer, or its user to the Web site. API keys are used to track and control how the API is being used\
- Example: if you want to use Google Maps' API, you register with Google and they will provide you an API key. With that API key, you will pass with any request to identify yourself while Google will also track your usage.\
- API Gateways allows you to individually grant API keys but you also have an automatic system where people can register for your API. \
- 
\f1\i Client Certificates
\f0\i0  are important if you plan on forwarding incoming requests to another HTTP endpoint and on that HTTP endpoint, you want to validate that the request this other HTTP endpoint gets, indeed stems from your API Gateway\
\
-IAM (Identity and Access Management)\
  - managing who can access what. Giving the right people that right services.\
\
Section 3.21\
- a resource, inside your API, is like a path i.e. a new path in the final URL you can use. \
- to bring API to life and expose API to the web, we always have to call deploy API. This leads to stages. Stages are like snapshots of your API, deployed snapshots. \
- 
\f1\i Models
\f0\i0  allows you to define the shape of the data you work with in your API. Models are created using the JSON schema language.\
  - You can use these models to validate incoming data, see if it fits that schema or reject it.\
- 
\f1\i Binary Support
\f0\i0  is important if you plan on sending files along with your requests\
  - to send these files unchanged to the receiving endpoint or to the code that actually handles the request, you have to register the file types.\
\
Section 3.22\
- an endpoint is made up of two things:\
   - resource: the path to which the request should get sent \
   - method: the type of request\
- you can test an endpoint inside API Gateway so we don\'92t have to set up a client to do the testing\
- Method Request (the first box) defines how requests reaching this endpoint should actually look like. It\'92s like a gatekeeper that can deny/accept\
	- You can validate your request using 3 types:\
	  - URL Query String Parameters: this is the text after the ? mark at the end\
	  - HTTP Request Headers: header fits our scheme or needs\
	  - Request Body: you can connect it to a model.\
\
Section 3.23\
- Integration Request: mapping or transforming incoming data (not just the body, but header or metadata like authenticated users) into a particular shape we want to use it on the action we are about to trigger.\
  - the role of the integration request is to trigger the endpoint.\
\
- integration Response: allows us to configure the response we\'92re sending back; opposite to what the integration request does. \
  - It fills that shape with life and is non-binding.\
- Method Response: defines the shape our response should have. Will never block the response because we always want to send back a response. You must first configure the headers under Method Response to be able to adjust them in the Integration Response. \
   - Method Response defines the boundaries of the set up\
\
Section 3.24\
- Swagger: is a definition or language which allows you define an API as a text file then import it AWS API Gateway\
\
Section 3.25\
- selecting the 
\f1\i Configure as proxy resource 
\f0\i0 means this will be a catch-all resource, catching all other paths and methods. A flexible path that could capture all requests if needed. Why do that?\
   - great for single page apps but it is limited to full-stack apps\
   - you capture all requests and send it to a Lambda function that will handle all requests (effectively creating a full-stack app with a server-less approach)\
- API Gateway CORS (Cross Origin Resource Sharing): a security model where, in general, we are not allows to access resources on a server from another server. One server needs to send the right headers telling the browser that this cross site access is OK. \
- Modern browsers send preflight requests that check if the resource or the post request is about to get to, is actually available and/or allowed.\
   - this extra request will be of type options, HTTP verb. Therefore, you need to provide an options endpoint so that the incoming request will be handled appropriately and return the right CORs headers to tell Chrome that it is okay to send POST request 
\f1\i EVEN though we are using different resources, different servers. \
- 
\f0\i0 Integration type simply means which kind of action do you want to execute whenever a request hits this resource. \
- Selecting Integration type: HTTP means we can forward it to another API.\
- Selecting the \'93Use Lambda Proxy Integration\'94 box, means that takes the incoming request and the request\'92s metadata and pass that unfiltered data as a JSON object to the Lambda function. \
   - This also means that in the Lambda function, you will have to extract what you need and in the end you will have to send back a response from Lambda. This means you won\'92t be using the native tools API Gateway gives you, like the integration response and integration request.\
\
Section 3.31\
- index.handler defines the entry point of your lambda code execution.\
  - Index.handler means whenever Lambda executes, it will not automatically run all JavaScript. Instead, it will run the file name \'93index\'94 with the function \'93handler. Basically, 
\f1\i file.function
\f0\i0 \
\
Section 3.34\
- It is important to test from the web (codepen.io) because CORS errors won\'92t pop up if you just test it in the API console.\
   - As how it is current set up, you will need to set up CORS headers on each method and not just on the OPTIONS method. \
\
Assignment 1 \
- Instead of setting up the CORS headers manually by going into Method Response, then Integration Response for every single method, you can automatically set it up by selecting \'93
\f1\i Enable CORS
\f0\i0 \'94
\f1\i  
\f0\i0 under Actions.\
\
\
Section 3.35\
- remember to enclose in parentheses the JSON properties of the Request Body\
- there are two points where you can adjust the data: Integration Request and Integration Response.\
\
Section 3.36\
- Using  \'93Use Lambda Proxy Integration\'94 box, sends all the data to the Lambda function instead of just the request body. \
- If you notice a section, like \'93Integration Response\'94, is grayed out then that means the data never gets to the part primarily because the request doesn\'92t fit the schema of the response.\
\
Section 3.37\
- Lambda stores its logs inside of another service called \'93Cloudwatch\'94\
- Pro for using the \'93Use Lambda Proxy Integration\'94 that returns all of the data is you get more info while the Con is that it takes a significant amount of work to access the body by Lambda that should be handled by API Gateway. There is a nicer alternative. \
\
Section 3.38\
- the name \'93application/json\'94 means that incoming requests with \'93Content-Type\'94 of \'93application/json\'94 will be handled by this template. \
- Integration request is where you can transform the incoming data and pass that same data in another shape.\
\
Section 3.39\
- AWS API Gateway has a language (templating language) that we can use to extract data from the request, in this case body mapping templates, which you can select by selecting \'93Method Request passthrough\'94 (uses Apache\'92s Velocity language). There is official documentation\
- this allows to you to not forward the entire request but a forwarding a mapped template (or a mapped event data object) with data from the request. In short, it simply allows you to control which data your action receives. \
   - the power lies in not having to parse JSON data because it is already a mapped JavaScript object instead\
   - also doesn\'92t override the Integration response. \
\
Section 3.40\
- In the API\'92s Gateway templating language, \'93$input\'94 refers to your data. It is a reserved variable. \
- pay attention to the naming of the properties (age) that are feed into your action (Lambda function)\
\
}