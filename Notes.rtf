{\rtf1\ansi\ansicpg1252\cocoartf1671\cocoasubrtf500
{\fonttbl\f0\fswiss\fcharset0 Helvetica;\f1\fswiss\fcharset0 Helvetica-Oblique;\f2\froman\fcharset0 Times-Roman;
\f3\fswiss\fcharset0 Helvetica-Bold;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue233;}
{\*\expandedcolortbl;;\cssrgb\c0\c0\c93333;}
\margl1440\margr1440\vieww15620\viewh8320\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs24 \cf0 Udemy AWS Severless- API & Apps Course Notes\
\
Section 1.6 \
- There are more advanced ways of creating APIs (e.g. by importing API definition files).\
- Mock response under the "Get" Method is a dummy response. \
- Stages are a feature which allow you to manage different versions of the API, like a development API and a production API.\
- remember to add to the end of the link. https://l3dtr5aq3b.execute-api.us-east-2.amazonaws.com/Development/first-api-udemy \
\
Section 1.7\
-Alternates to AWS include Microsoft's Azure and Google Cloud Platform\
\
Section 2.12\
-S3 (Simple Storage Service)\
  - doesn't support any server-side code\
-API Gateway\
  - a service to create API with different paths and HTTP methods we want to handle\
-Lambda\
  - allows you to execute code on demand\
-DynamoDB\
  - NoSQL database where we don't have to provision any database servers. \
-Cognito\
  - creates user pools to allow users to sign-up and then sign themselves in.\
-Route 53\
  - allows us to register and configure our own domain. \
-Cloud front (optional)\
  - caching service used to improve performance and delivery time \
  - basically copy your static files to always have the quickest route possible\
\
\
Section 3.16\
-API Gateways can create endpoints, which are combinations of resources, paths and HTTP methods so that you can get URLs.\
\
Section 3.19\
- API keys are useful if you plan on creating an API  which is shared with other developers\
- API keys are used to identify the calling program, its developer, or its user to the Web site. API keys are used to track and control how the API is being used\
- Example: if you want to use Google Maps' API, you register with Google and they will provide you an API key. With that API key, you will pass with any request to identify yourself while Google will also track your usage.\
- API Gateways allows you to individually grant API keys but you also have an automatic system where people can register for your API. \
- 
\f1\i Client Certificates
\f0\i0  are important if you plan on forwarding incoming requests to another HTTP endpoint and on that HTTP endpoint, you want to validate that the request this other HTTP endpoint gets, indeed stems from your API Gateway\
\
-IAM (Identity and Access Management)\
  - managing who can access what. Giving the right people that right services.\
\
Section 3.21\
- a resource, inside your API, is like a path i.e. a new path in the final URL you can use. \
- to bring API to life and expose API to the web, we always have to call deploy API. This leads to stages. Stages are like snapshots of your API, deployed snapshots. \
- 
\f1\i Models
\f0\i0  allows you to define the shape of the data you work with in your API. Models are created using the JSON schema language.\
  - You can use these models to validate incoming data, see if it fits that schema or reject it.\
- 
\f1\i Binary Support
\f0\i0  is important if you plan on sending files along with your requests\
  - to send these files unchanged to the receiving endpoint or to the code that actually handles the request, you have to register the file types.\
\
Section 3.22\
- an endpoint is made up of two things:\
   - resource: the path to which the request should get sent \
   - method: the type of request\
- you can test an endpoint inside API Gateway so we don\'92t have to set up a client to do the testing\
- Method Request (the first box) defines how requests reaching this endpoint should actually look like. It\'92s like a gatekeeper that can deny/accept\
	- You can validate your request using 3 types:\
	  - URL Query String Parameters: this is the text after the ? mark at the end\
	  - HTTP Request Headers: header fits our scheme or needs\
	  - Request Body: you can connect it to a model.\
\
Section 3.23\
- Integration Request: mapping or transforming incoming data (not just the body, but header or metadata like authenticated users) into a particular shape we want to use it on the action we are about to trigger.\
  - the role of the integration request is to trigger the endpoint.\
\
- integration Response: allows us to configure the response we\'92re sending back; opposite to what the integration request does. \
  - It fills that shape with life and is non-binding.\
- Method Response: defines the shape our response should have. Will never block the response because we always want to send back a response. You must first configure the headers under Method Response to be able to adjust them in the Integration Response. \
   - Method Response defines the boundaries of the set up\
\
Section 3.24\
- Swagger: is a definition or language which allows you define an API as a text file then import it AWS API Gateway\
\
Section 3.25\
- selecting the 
\f1\i Configure as proxy resource 
\f0\i0 means this will be a catch-all resource, catching all other paths and methods. A flexible path that could capture all requests if needed. Why do that?\
	- great for single page apps but it is limited to full-stack apps\
	- you capture all requests and send it to a Lambda function that will handle all requests (effectively creating a full-stack app with a server-less approach)\
- API Gateway CORS (Cross Origin Resource Sharing): a security model where, in general, we are not allowed to access resources on a server from another server. One server needs to send the right headers telling the browser that this cross site access is OK. \
- Modern browsers send preflight requests that check if the resource or the post request is about to get to, is actually available and/or allowed.\
	- this extra request will be of type options, HTTP verb. Therefore, you need to provide an options endpoint so that the incoming request will be handled appropriately and return the right CORs headers to tell Chrome that it is okay to send POST request 
\f1\i EVEN though we are using different resources, different servers. \
- 
\f0\i0 Integration type simply means which kind of action do you want to execute whenever a request hits this resource. \
- Selecting Integration type: HTTP means we can forward it to another API.\
- Selecting the \'93Use Lambda Proxy Integration\'94 box, means that takes the incoming request and the request\'92s metadata and pass that unfiltered data as a JSON object to the Lambda function. \
   - This also means that in the Lambda function, you will have to extract what you need and in the end you will have to send back a response from Lambda. This means you won\'92t be using the native tools API Gateway gives you, like the integration response and integration request.\
\
Section 3.31\
- index.handler defines the entry point of your lambda code execution.\
  - Index.handler means whenever Lambda executes, it will not automatically run all JavaScript. Instead, it will run the file name \'93index\'94 with the function \'93handler. Basically, 
\f1\i file.function
\f0\i0 \
\
Section 3.34\
- It is important to test from the web (codepen.io) because CORS errors won\'92t pop up if you just test it in the API console.\
   - As how it is current set up, you will need to set up CORS headers on each method and not just on the OPTIONS method. \
\
Assignment 1 \
- Instead of setting up the CORS headers manually by going into Method Response, then Integration Response for every single method, you can automatically set it up by selecting \'93
\f1\i Enable CORS
\f0\i0 \'94
\f1\i  
\f0\i0 under Actions.\
\
\
Section 3.35\
- remember to enclose in parentheses the JSON properties of the Request Body\
- there are two points where you can adjust the data: Integration Request and Integration Response.\
\
Section 3.36\
- Using  \'93Use Lambda Proxy Integration\'94 box, sends all the data to the Lambda function instead of just the request body. \
- If you notice a section, like \'93Integration Response\'94, is grayed out then that means the data never gets to the part primarily because the request doesn\'92t fit the schema of the response.\
\
Section 3.37\
- Lambda stores its logs inside of another service called \'93Cloudwatch\'94\
- Pro for using the \'93Use Lambda Proxy Integration\'94 that returns all of the data is you get more info while the Con is that it takes a significant amount of work to access the body by Lambda that should be handled by API Gateway.\
\
Section 3.38\
- the name \'93application/json\'94 means that incoming requests with \'93Content-Type\'94 of \'93application/json\'94 will be handled by this template. \
- Integration request is where you can transform the incoming data and pass that same data in another shape.\
\
Section 3.39\
- AWS API Gateway has a language (templating language) that we can use to extract data from the request, in this case body mapping templates, which you can select by selecting \'93Method Request passthrough\'94 (uses Apache\'92s Velocity language). There is official documentation\
- this allows to you to not forward the entire request but a forwarding a mapped template (or a mapped event data object) with data from the request. In short, it simply allows you to control which data your action receives. \
   - the power lies in not having to parse JSON data because it is already a mapped JavaScript object instead\
   - also doesn\'92t override the Integration response. \
\
Section 3.40\
- In the API\'92s Gateway templating language, \'93$input\'94 refers to your data. It is a reserved variable. \
- pay attention to the naming of the properties (age) that are feed into your action (Lambda function)\
\
Section 3.42\
- \'93$input\'94 is the callback info sent back by Lambda, \'93json(\'91$\'92)\'94 then gives us back all the data passed with the callback. \
- The philosophy here is we don\'92t have to adjust our Lambda function to our client, we only have to adjust our API Gateway to our client and transform the data we get back. However, I can see instances where different clients with different necessities might need the data in a different format so Lambda might be the place to identify that and adjust the data there. Might be possible to do it in API Gateway too.\
\
Section 3.43\
- status code 400: request is blocked\
\
Section 3.44\
- JSON schemas: {\field{\*\fldinst{HYPERLINK "http://json-schema.org/understanding-json-schema/index.html"}}{\fldrslt 
\f2 \cf2 \expnd0\expndtw0\kerning0
\ul \ulc2 \outl0\strokewidth0 \strokec2 http://json-schema.org/understanding-json-schema/index.html}}\
\
Section 3.45\
- the whole idea of using models is optional however with API Gateway, you get an out-of-the-box working implementation of validation which returns an error if it fails. \
- you can also use models to map data apart from validation.\
- $input.path(\'91$\'92) is all the data that is returned by Lambda. \
\
Assignment 2\
- In mapping techniques, you are transforming data. In models, you are defining the structure of the data. \
\
Section 3.48 (
\f3\b\fs26 Don\'92t Fully Understand, need to revisit
\f0\b0\fs24 )\
- Need to understand the difference between path variable vs query parameters \
- Adding a GET METHOD with a variable path that is flexible.\
- You can add path parameters using brackets. For example, the resource path \{username\} represents a path parameter called 'username'.\
	- \{parmeter\}\
- API Gateway automatically detects the number of parameters. \
- The default of the integration request is to pass only the request body \
   - the problem here is that the GET request doesn\'92t have a request body so the data has to be encoded in the URL\
   - that is the reason why we are using a template. \
- API Gateway manages a 
\f1\i params 
\f0\i0 object where it has key-value pairs\
	- where the keys are the names we specify here between the curly braces (parameter) and \
	- the values are the actual values we then send when we replace these dynamic values with 
\f1\i real values in the URL.
\f0\i0 \
	- Example: if our URL is 
\f1\i myapi.com/\{type\}. 
\f0\i0 Then in practice we send a request 
\f1\i myapi.com/all
\f0\i0  or 
\f1\i myapi.com/single
\f0\i0 . API Gateway will extract that value (
\f1\i all 
\f0\i0 or 
\f1\i single
\f0\i0 ) and store it in this 
\f1\i params
\f0\i0  object.\
- in order for the response to be passed as a string, we need to enclose value we extract from the URL in double quotation marks like so:\
	- \{ \'93type\'94: 
\f1\i \'93$input.params(\'91type\'92)\'94  
\f0\i0 \}\
	- because in this case, our lambda function is comparing the value to a string. \
\
\
\
}